#! /usr/bin/env php
<?php
require_once __DIR__ . '/vendor/autoload.php';

CVEScore::main($_SERVER['argv']);
class CVEScore
{

    private function __construct(array $argv)
    {
        $this->argv = $argv;
    }

    private function getCVEContent(string $cveId): array
    {

        $uri = sprintf(
            '%s?cveId=%s'
            , self::CVE_BASE_URI
            , $cveId
        );
        $curl = curl_init($uri);
        curl_setopt_array($curl, [
            CURLOPT_RETURNTRANSFER => true,
            CURLOPT_USERAGENT => 'Mozilla',
            CURLOPT_FAILONERROR => true,
        ]);
        $contentJson = curl_exec($curl);

        if(curl_errno($curl) !== 0 || curl_getinfo($curl,  CURLINFO_RESPONSE_CODE) != 200) {
            throw new \RuntimeException(sprintf(
                    'An error occured when trying to read %s. Status %s ; %d, %s'
                , var_export($cveId, true)
                , curl_getinfo($curl, CURLINFO_RESPONSE_CODE)
                , curl_errno($curl)
                , curl_error($curl)
            ));
        }
        return json_decode($contentJson, true);
    }

    private function storeCVE(string $cveId, array $data): self {

        $this->result[$cveId] = [];

        $versionFilter = $this->cliArgs->getOpt('filter-version', null);

        foreach($data['vulnerabilities'] as $vulnerabilities) {
            foreach($vulnerabilities['cve']['metrics'] as $metrics) {
                foreach($metrics as $metric) {
                    $version = $metric['cvssData']['version'];
                    if(null !== $versionFilter && $versionFilter !== $version) {
                        continue;
                    }
                    if(!array_key_exists($version, $this->result[$cveId])) {
                        $this->result[$cveId][$version] = [];
                    }

                    $this->result[$cveId][$version][] = [
                        'version' => $version,
                        'source' => $metric['source'],
                        'vectorString' => $metric['cvssData']['vectorString'],
                        'baseScore' => $metric['cvssData']['baseScore'],
                        'baseSeverity' => $metric['cvssData']['baseSeverity'] ?? 'n/a',
                        'exploitabilityScore' => $metric['exploitabilityScore'],
                        'impactScore' => $metric['impactScore'],
                    ];
                }
            }
        }

        return $this;
    }

    private function processCommandline(): self
    {

        $cli = new \Garden\Cli\Cli();
        $this->cliArgs = $cli
            ->description('Fetch CVE score information from ' . self::CVE_BASE_URI)
            ->opt(
                'filter-version',
                'Filter for a specific cvss version'
            )
            ->opt(
                'output:o',
                sprintf('Output format %s', implode('|', $this->validOutputFormat))
            )
            ->opt(
                'sleep:s',
                'sleep for the given seconds between api requests', false, 'int'
            )
            ->opt(
                    'verbose:v',
                'Be more verbose (to stderr)', false, 'bool'
            )
            ->arg('CVE-ID', 'fetch information on these ids', true )
            ->parse($this->argv, true)
        ;

        // check options
        $outputType = $this->cliArgs->getOpt('output', self::OUTPUT_PLAIN);
        if(!in_array($outputType, $this->validOutputFormat)) {
            throw new \RuntimeException(sprintf('Invalid output type: %s', var_export($outputType, true)));
        }

        // check cve(s)
        $invalid = [];
        foreach($this->cliArgs->getArgs() as $cveId) {
            $match = preg_match(
        '/^CVE-[0-9]{4}-[0-9]{4,}$/',$cveId
            );
            if(0 === $match) {
                $invalid[] = $cveId;
            }
        }
        if(count($invalid)) {
            throw new \RuntimeException(sprintf(
                'Invalid CVE Id%s found: %s'
                , 1 === count($invalid) ? '' : 's'
                , implode(', ', $invalid)
            ));
        }

        return $this;
    }
    private function process(): self
    {

        $num = 0;
        $cveIDs = array_unique($this->cliArgs->getArgs());
        $this->verboseOut('Fetching data for %d CVE%s', count($cveIDs), 1===count($cveIDs)?'':'s');
        $sleep = $this->cliArgs->getOpt('sleep', null);
        foreach($cveIDs as $cveId) {
            $this->verboseOut('Fetching %sâ€¦', $cveId);
            $content = $this->getCVEContent($cveId);
            $this->storeCVE($cveId, $content);
            if(null !== $sleep && ++$num < count($cveIDs)) {
                $this->verboseOut('Sleep %d second%s between requests', $sleep, 1===$sleep?'':'s');
                sleep($sleep);
            }
        }

        return $this;
    }

    private function printCsv(): self {
        fputcsv(
    STDOUT, [
                'cve', 'version', 'score', 'severity', 'vector', 'exploit', 'impact', 'source'
            ]
        );
        foreach($this->result as $cveID => $versions) {
            foreach($versions as $version => $rows) {
                foreach($rows as $row) {
                    fputcsv(
                STDOUT, [
                            $cveID,
                            $version,
                            $row['baseScore'],
                            $row['baseSeverity'],
                            $row['vectorString'],
                            $row['exploitabilityScore'],
                            $row['impactScore'],
                            $row['source'],
                        ]
                    );
                }
            }
        }

        return $this;
    }

    private function printJson(): self {
        echo json_encode($this->result, JSON_PRETTY_PRINT);
        return $this;
    }

    private function printPlain(): self {
        $header = [
                'version', 'score', 'severity', 'vector', 'exploit', 'impact', 'source'
        ];

        foreach($this->result as $cveID => $versions) {
            echo $cveID, PHP_EOL;
            $table = new \Garden\Cli\Table();
            $table->row();
            foreach($header as $column) {
                $table->cell($column);
            }
            foreach($versions as $version => $rows) {
                foreach($rows as $row) {
                    $table
                        ->row()
                        ->cell($version)
                        ->cell($row['baseScore'])
                        ->cell($row['baseSeverity'])
                        ->cell($row['vectorString'])
                        ->cell($row['exploitabilityScore'])
                        ->cell($row['impactScore'])
                        ->cell($row['source'])
                    ;
                }
            }
            $table->write();
        }

        return $this;
    }

    private function print(): self
    {

        switch($this->cliArgs->getOpt('output', self::OUTPUT_PLAIN)) {
            case self::OUTPUT_CSV:
                $this->printCsv();
                break;

            case self::OUTPUT_JSON:
                $this->printJson();
                break;

            case self::OUTPUT_PLAIN:
            default:
                $this->printPlain();
                break;
        }

        return $this;
    }

    private function verboseOut(string $message, ...$values): self
    {
        if($this->cliArgs->getOpt('verbose', false)) {
            $bt = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS);
            $from = sprintf(
                '[%s::%s()@%d] '
                , $bt[1]['class']
                , $bt[1]['function']
                , $bt[0]['line']

            );
            $output = count($values)
                ? vsprintf($message, $values)
                : $message
            ;
            fputs(STDERR, $from . rtrim($output) . PHP_EOL);
        }

        return $this;
    }

    private function run(): self
    {

        $this
            ->processCommandline()
            ->process()
            ->print()
        ;
        return $this;
    }

    public static function main(array $argv)
    {

        $obj = new self($argv);
        $obj->run();

    }

    private const CVE_BASE_URI = 'https://services.nvd.nist.gov/rest/json/cves/2.0';
    private const OUTPUT_PLAIN = 'plain';
    private const OUTPUT_JSON = 'json';
    private const OUTPUT_CSV = 'csv';

    private $validOutputFormat = [
        self::OUTPUT_PLAIN,
        self::OUTPUT_JSON,
        self::OUTPUT_CSV,
    ];

    private \Garden\Cli\Args $cliArgs;

    private array $argv;
    private array $result = [];

}